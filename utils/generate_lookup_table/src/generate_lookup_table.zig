//:============================================================================================
//: MIT License
//:
//: Copyright (c) 2024 7r35c0
//:
//: Permission is hereby granted, free of charge, to any person obtaining a copy
//: of this software and associated documentation files (the "Software"), to deal
//: in the Software without restriction, including without limitation the rights
//: to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//: copies of the Software, and to permit persons to whom the Software is
//: furnished to do so, subject to the following conditions:
//:
//: The above copyright notice and this permission notice shall be included in all
//: copies or substantial portions of the Software.
//:
//: THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//: IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//: FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//: AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//: LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//: OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//: SOFTWARE.
//:============================================================================================

// The algorithm code is based on following sources:
// * CodeMaze - Whatâ€™s the Best Way to Count the Digits in a Number
// https://code-maze.com/csharp-whats-the-best-way-to-count-the-number-of-digits-in-a-number/
// https://github.com/CodeMazeBlog/CodeMazeGuides/tree/main/numbers-csharp/CountNumberOfDigitsInANumber
// * Daniel Lemire's blog - Computing the number of digits of an integer even faster
// https://lemire.me/blog/2021/06/03/computing-the-number-of-digits-of-an-integer-even-faster/
// https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2021/06/03

// Tested with zig version 0.13.0 on Linux Fedora 39.

const std = @import("std");
const pow = std.math.pow;

/// Generates for a number of `bits`, the lookup table used in `count_digit_lookup` algorithm.
///
/// Supported bits range, less than 1024.
pub fn LookupTable(comptime bits: u16) type {
    //^ for `bits >= 1024` errors occur
    //^ panic: integer part of floating point value out of bounds for `@intFromFloat()`
    if (bits >= 1024) {
        @compileError("unsupported number of bits `" ++ std.fmt.comptimePrint("{}", .{bits}) ++ "` - LookupTable() is not implemented for a number of bits >= 1024");
    }

    return struct {
        table: [bits]Table,

        const Table = std.meta.Int(
            .unsigned,
            @as(u16, bits * 2),
        );

        const Self = @This();

        pub fn generate() Self {
            var tbl = [_]Table{0} ** bits;

            for (&tbl, 0..) |*val, idx| {
                if (idx < bits - 2) {
                    const small = @as(
                        Table,
                        @intFromFloat(@ceil(@log10(pow(
                            f64,
                            2,
                            @as(f64, @floatFromInt(idx)),
                        )))),
                    );

                    val.* = @shlExact(small, bits) +
                        pow(Table, 2, bits) -
                        pow(Table, 10, small);
                } else {
                    const large = @as(
                        Table,
                        @intFromFloat(@ceil(@log10(pow(
                            f64,
                            2,
                            @as(f64, @floatFromInt(idx + 1)),
                        ) - 1))),
                    );

                    val.* = @shlExact(large, bits);
                }
            }

            return Self{
                .table = tbl,
            };
        }
    };
}

//+============================================================================================
//+ Tests: 8, 16, 32, 64, 128 bits
//+============================================================================================

test "generateLookupTable()" {
    const expect = std.testing.expectEqualDeep;

    {
        const bit = 8;
        const tbl = [bit]u16{ 255, 502, 502, 502, 668, 668, 768, 768 };

        try expect(tbl, LookupTable(bit).generate().table);
    }

    {
        const bit = 16;
        const tbl = [bit]u32{ 65535, 131062, 131062, 131062, 196508, 196508, 196508, 261144, 261144, 261144, 317680, 317680, 317680, 317680, 327680, 327680 };

        try expect(tbl, LookupTable(bit).generate().table);
    }

    {
        const bit = 32;
        const tbl = [bit]u64{ 4294967295, 8589934582, 8589934582, 8589934582, 12884901788, 12884901788, 12884901788, 17179868184, 17179868184, 17179868184, 21474826480, 21474826480, 21474826480, 21474826480, 25769703776, 25769703776, 25769703776, 30063771072, 30063771072, 30063771072, 34349738368, 34349738368, 34349738368, 34349738368, 38554705664, 38554705664, 38554705664, 41949672960, 41949672960, 41949672960, 42949672960, 42949672960 };

        try expect(tbl, LookupTable(bit).generate().table);
    }

    {
        const bit = 64;
        const tbl = [bit]u128{ 18446744073709551615, 36893488147419103222, 36893488147419103222, 36893488147419103222, 55340232221128654748, 55340232221128654748, 55340232221128654748, 73786976294838205464, 73786976294838205464, 73786976294838205464, 92233720368547748080, 92233720368547748080, 92233720368547748080, 92233720368547748080, 110680464442257209696, 110680464442257209696, 110680464442257209696, 129127208515965861312, 129127208515965861312, 129127208515965861312, 147573952589666412928, 147573952589666412928, 147573952589666412928, 147573952589666412928, 166020696663285964544, 166020696663285964544, 166020696663285964544, 184467440736095516160, 184467440736095516160, 184467440736095516160, 202914184800805067776, 202914184800805067776, 202914184800805067776, 202914184800805067776, 221360928784514619392, 221360928784514619392, 221360928784514619392, 239807671958224171008, 239807671958224171008, 239807671958224171008, 258254407031933722624, 258254407031933722624, 258254407031933722624, 258254407031933722624, 276701061105643274240, 276701061105643274240, 276701061105643274240, 295146905179352825856, 295146905179352825856, 295146905179352825856, 313584649253062377472, 313584649253062377472, 313584649253062377472, 313584649253062377472, 331941393326771929088, 331941393326771929088, 331941393326771929088, 349488137400481480704, 349488137400481480704, 349488137400481480704, 358934881474191032320, 358934881474191032320, 350488137400481480704, 368934881474191032320 };

        try expect(tbl, LookupTable(bit).generate().table);
    }

    {
        const bit = 128;
        const tbl = [bit]u256{ 340282366920938463463374607431768211455, 680564733841876926926749214863536422902, 680564733841876926926749214863536422902, 680564733841876926926749214863536422902, 1020847100762815390390123822295304634268, 1020847100762815390390123822295304634268, 1020847100762815390390123822295304634268, 1361129467683753853853498429727072844824, 1361129467683753853853498429727072844824, 1361129467683753853853498429727072844824, 1701411834604692317316873037158841047280, 1701411834604692317316873037158841047280, 1701411834604692317316873037158841047280, 1701411834604692317316873037158841047280, 2041694201525630780780247644590609168736, 2041694201525630780780247644590609168736, 2041694201525630780780247644590609168736, 2381976568446569244243622252022376480192, 2381976568446569244243622252022376480192, 2381976568446569244243622252022376480192, 2722258935367507707706996859454135691648, 2722258935367507707706996859454135691648, 2722258935367507707706996859454135691648, 2722258935367507707706996859454135691648, 3062541302288446171170371466885813903104, 3062541302288446171170371466885813903104, 3062541302288446171170371466885813903104, 3402823669209384634633746074316682114560, 3402823669209384634633746074316682114560, 3402823669209384634633746074316682114560, 3743106036130323098097120681739450326016, 3743106036130323098097120681739450326016, 3743106036130323098097120681739450326016, 3743106036130323098097120681739450326016, 4083388403051261561560495289081218537472, 4083388403051261561560495289081218537472, 4083388403051261561560495289081218537472, 4423670769972200025023869895612986748928, 4423670769972200025023869895612986748928, 4423670769972200025023869895612986748928, 4763953136893138488487244494044754960384, 4763953136893138488487244494044754960384, 4763953136893138488487244494044754960384, 4763953136893138488487244494044754960384, 5104235503814076951950619011476523171840, 5104235503814076951950619011476523171840, 5104235503814076951950619011476523171840, 5444517870735015415413992718908291383296, 5444517870735015415413992718908291383296, 5444517870735015415413992718908291383296, 5784800237655953878877358326340059594752, 5784800237655953878877358326340059594752, 5784800237655953878877358326340059594752, 5784800237655953878877358326340059594752, 6125082604576892342340642933771827806208, 6125082604576892342340642933771827806208, 6125082604576892342340642933771827806208, 6465364971497830805803117541203596017664, 6465364971497830805803117541203596017664, 6465364971497830805803117541203596017664, 6805647338418769269257492148635364229120, 6805647338418769269257492148635364229120, 6805647338418769269257492148635364229120, 6805647338418769269257492148635364229120, 7145929705339707732630866756067132440576, 7145929705339707732630866756067132440576, 7145929705339707732630866756067132440576, 7486212072260646195194241363498900652032, 7486212072260646195194241363498900652032, 7486212072260646195194241363498900652032, 7826494439181584649657615970930668863488, 7826494439181584649657615970930668863488, 7826494439181584649657615970930668863488, 7826494439181584649657615970930668863488, 8166776806102523023120990578362437074944, 8166776806102523023120990578362437074944, 8166776806102523023120990578362437074944, 8507059173023460586584365185794205286400, 8507059173023460586584365185794205286400, 8507059173023460586584365185794205286400, 8847341539944390050047739793225973497856, 8847341539944390050047739793225973497856, 8847341539944390050047739793225973497856, 8847341539944390050047739793225973497856, 9187623906865238513511114400657741709312, 9187623906865238513511114400657741709312, 9187623906865238513511114400657741709312, 9527906273785276976974489008089509920768, 9527906273785276976974489008089509920768, 9527906273785276976974489008089509920768, 9868188640697215440437863615521278132224, 9868188640697215440437863615521278132224, 9868188640697215440437863615521278132224, 9868188640697215440437863615521278132224, 10208471007528153903901238222953046343680, 10208471007528153903901238222953046343680, 10208471007528153903901238222953046343680, 10548753373549092367364612830384814555136, 10548753373549092367364612830384814555136, 10548753373549092367364612830384814555136, 10889035731470030830827987437816582766592, 10889035731470030830827987437816582766592, 10889035731470030830827987437816582766592, 11229318008390969294291362045248350978048, 11229318008390969294291362045248350978048, 11229318008390969294291362045248350978048, 11229318008390969294291362045248350978048, 11569599475311907757754736652680119189504, 11569599475311907757754736652680119189504, 11569599475311907757754736652680119189504, 11909872842232846221218111260111887400960, 11909872842232846221218111260111887400960, 11909872842232846221218111260111887400960, 12250065209153784684681485867543655612416, 12250065209153784684681485867543655612416, 12250065209153784684681485867543655612416, 12250065209153784684681485867543655612416, 12589447576074723148144860474975423823872, 12589447576074723148144860474975423823872, 12589447576074723148144860474975423823872, 12920729942995661611608235082407192035328, 12920729942995661611608235082407192035328, 12920729942995661611608235082407192035328, 13171012309916600075071609689838960246784, 13171012309916600075071609689838960246784, 13171012309916600075071609689838960246784, 13271012309916600075071609689838960246784, 13271012309916600075071609689838960246784 };

        try expect(tbl, LookupTable(bit).generate().table);
    }
}
